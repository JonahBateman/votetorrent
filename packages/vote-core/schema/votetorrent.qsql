create view ElectionType as select * from (values ('o', 'Official'), ('a', 'Adhoc')) as ElectionType(Code, Name);

-- insert into Signing (Nonce, AuthoritySid, AdminEffectiveAt, Scope, Digest, UserSid, SignerKey, Signature) values ('blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah');
-- insert into Singature (Nonce, AuthoritySid, AdminEffectiveAt, Scope, Digest, UserSid, SignerKey, Signature) values ('blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah');
-- given SigningNonce = 'blah'
-- 	insert into AdminSigning (Nonce, AuthoritySid, AdminEffectiveAt, Scope, Digest, UserSid, SignerKey, Signature) values ('blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah');

create table Network (
	Sid text, -- H(PrimaryAuthoritySid, Name, ImageRef, Relays, TimestampAuthorities, NumberRequiredTSAs, ElectionType) at creation
	Hash text, -- H16(Sid)
	PrimaryAuthoritySid text,
	Name text,
	ImageRef text, -- json object { url?: string, cid?: string }
	Relays text, -- json array of strings - TODO: constraint
	TimestampAuthorities text, -- json array of { url: string } - TODO: constraint
	NumberRequiredTSAs integer default 0,
	ElectionType text, -- references ElectionType(Code)
	SigningNonce text null,
	primary key (),
	constraint CantDelete check on delete (false),
	constraint SidValid check on insert (Sid = Digest(PrimaryAuthoritySid, Name, ImageRef, Relays, TimestampAuthorities, NumberRequiredTSAs, ElectionType)),
	constraint SidImmutable check on update (new.Sid = old.Sid),
	-- TODO: constraint HashValid check on insert (Hash = H16(Sid)),
	constraint HashImmutable check on update (new.Hash = old.Hash),
	-- Note: primary authority is validated via an assertion
	-- TODO: constraint ImageRefValid check (ImageRef is a valid image reference JSON)
	-- TODO: constraint RelaysValid check (Relays is a valid array of strings)
	-- TODO: constraint TimestampAuthoritiesValid check (TimestampAuthorities is a valid array of { url: string })
	constraint NumberRequiredTSAsValid check (NumberRequiredTSAs >= 0 and typeof(new.NumberRequiredTSAs) = 'integer'),
	constraint ElectionTypeValid check (ElectionType in (select Code from ElectionType)),
	constraint NoSigningNonceOnInsert check on insert (SigningNonce is null),
	constraint UpdateNetworkValid check on update (
		-- Only the primary authority can update the network
		exists (select 1 from AdminSignature ADS
			join AdminSigning A on A.Nonce = ADS.Nonce and A.AuthoritySid = new.PrimaryAuthoritySid
			where ADS.Nonce = new.SigningNonce
				and A.Scope = 'rn'
		)
	)
)
	with context on update, delete ( SigningNonce text );

create view Scope as select * from (values
	('rn', 'Revise Network'),
	('rad', 'Revise or replace the Admin'),
	('vrg', 'Validate registrations'),
	('iad', 'Invite other Authorities'),
	('uai', 'Update Authority Information'),
	('ceb', 'Create/Edit ballot templates'),
	('mel', 'Manage Elections'),
	('cap', 'Configure Authority Peers')
) as Scope(Code, Name);

create table Authority (
	Sid text, -- H(Name, DomainName, ImageRef, InviteSlotCid, InviteSignature) at creation
	Name text,
	DomainName text null,
	ImageRef text null, -- json object { url?: string, cid?: string }
	SigningNonce text null,
	InviteSlotCid text null,
	InviteSignature text null,
	primary key (Sid),
	constraint CantDelete check on delete (false),
	constraint NewSidValid check on insert (Sid = Digest(Name, DomainName, ImageRef, InviteSlotCid, InviteSignature)),
	constraint SidImmutable check on update (new.Sid = old.Sid),
	-- TODO: constraint ImageRefValid check (ImageRef is a valid image reference JSON)
	constraint NoSigningNonceOnInsert check on insert (SigningNonce is null),
	constraint NewAuthorityValid check on insert (
		-- Very first authority in the network - shoe-in, no Invite
		not exists (select 1 from Authority)
			-- or Valid Invite for this authority
			or exists (
				select 1 from InviteResult R
					join InviteSlot S on S.Cid = R.SlotCid
					join AdminSigning A on A.Nonce = S.SigningNonce
					where A.Scope = 'iad' and R.SlotCid = new.InviteSlotCid
						and R.IsAccepted and SignatureValid(Digest(new.Sid), R.InviteSignature, S.InviteKey)
			)
	),
	constraint UpdateAuthorityValid check on update (
		exists (select 1 from AdminSignature ADS
			join AdminSigning A on A.Nonce = ADS.Nonce and A.AuthoritySid = new.Sid and A.Scope = 'uai'
			where ADS.Nonce = new.SigningNonce)
	)
);

create assertion PrimaryAuthorityValid check (not exists (
	select 1 from Network N where not exists (
		select 1 from Authority A where A.Sid = N.PrimaryAuthoritySid
	)
));

-- Administration
create table Admin (
	AuthoritySid text,
	EffectiveAt datetime,
	ThresholdPolicies text default '[]', -- json array of { scope: string, threshold: integer } - if not set for a scope, 1 is assumed
	SigningNonce text null,  -- The signing from the previous Admin, if there was one, or the inviter for first in a new authority
	InviteSignature text null,	-- Authority's invite signature for H(AuthoritySid, EffectiveAt, ThresholdPolicies)
	primary key (AuthoritySid, EffectiveAt),
	constraint CantDelete check on delete (false),
	constraint AuthoritySidValid check (exists (select 1 from Authority A where A.Sid = new.AuthoritySid)),
	-- Replace with isISODatetime when available
	constraint EffectiveAtValid check (datetime(EffectiveAt) is not null),
	-- TODO: constraint ThresholdPoliciesValid check (valid json array of { scope: string, threshold: integer }),
	constraint NewAdminValid check on insert (
		-- Very first Admin in the network - shoe-in, no Invite
		not exists (select 1 from Admin)
			-- Valid Invite for first admin on this authority
			or (
				-- First admin for the authority
				not exists(select 1 from Admin A where A.AuthoritySid = new.AuthoritySid)
					-- Signed by the authority's inviter
					and exists (
						select 1 from Authority A
							join InviteSlot S on A.InviteSlotCid = S.Cid
							where A.Sid = new.AuthoritySid
								and SignatureValid(Digest(new.Sid), new.InviteSignature, S.InviteKey)
					)
			)
			or (
				-- Not the first admin for the authority, but has a valid signing
				exists (select 1 from AdminSignature ADS
					join AdminSigning S on S.Nonce = ADS.Nonce and S.AuthoritySid = new.AuthoritySid and S.Scope = 'rad'
					where ADS.Nonce = new.SigningNonce)
			)
	),
	constraint UpdateAdminValid check on update (exists (
		select 1 from AdminSignature ADS
			join AdminSigning S on S.Nonce = ADS.Nonce and S.AuthoritySid = new.AuthoritySid and S.Scope = 'rad'
			where ADS.Nonce = new.SigningNonce
			-- TODO: how to verify the signing digest - spans tables
	))
);

create view CurrentAdmin as
	select AuthoritySid, max(EffectiveAt) as EffectiveAt
		from Admin
		where EffectiveAt <= datetime('now')
		group by AuthoritySid;

create table Officer (
	AuthoritySid text,
	AdminEffectiveAt datetime,
	UserSid text,
	Title text,
	Scopes text default '[]', -- json array of strings
	SignerKey text,
	Signature text,
	primary key (AuthoritySid, AdminEffectiveAt, UserSid),
	constraint AuthoritySidValid check (exists (select 1 from Authority A where A.Sid = new.AuthoritySid)),
	constraint UserSidValid check (exists (select 1 from User U where U.Sid = new.UserSid)),
	constraint AdminValid check (exists (select 1 from Admin A where A.AuthoritySid = new.AuthoritySid and A.EffectiveAt = new.AdminEffectiveAt)),
	constraint InsertOnly check on update, delete (false),
	constraint ScopesValid check (not exists (select 1 from json_array_elements_text(Scopes) S(s) where s not in (select Code from Scope))),
	constraint SignerKeyValid check (exists (select 1 from UserKey K where K.UserSid = new.UserSid and K.Key = new.SignerKey and K.Expiration > datetime('now')))
	-- constraint SignatureValid check (SignatureValid(
	-- 	Digest(AuthoritySid, AdminEffectiveAt, UserSid, Title, Scopes),
	-- 	Signature,
	-- 	SignerKey)
	-- )
	-- TODO: transaction level constraint that Officers and Admin are inserted together
);

create assertion AdminValid check (not exists (
	-- Threshold policies are valid - the number of Officers for each scope is at least the threshold
	select 1 from Admin A
		where exists (select 1 from json_array_elements_text(A.ThresholdPolicies) TP(tp)
			where tp.threshold > (select count(*) from Officer AD
				where A.AuthoritySid = AD.AuthoritySid and A.AdminEffectiveAt = AD.AdminEffectiveAt
					and tp.scope in (select policy from json_array_elements_text(AD.Scopes) S(s) where s = tp.scope)
			)
		)
));

create index OfficerUser on Officer (UserSid); -- include (Scopes)

-- Note: proposed aren't dependencies, just a workflow for constructing a fully signed admin

-- A signing "session" for an Admin
create table AdminSigning (
	Nonce text, -- Random ID
	AuthoritySid text,
	AdminEffectiveAt datetime,
	Scope text, -- references Scope(Code)
	Digest text, -- Content hash to be signed - Base64url encoded sha256
	UserSid text, -- Officer who is instigator the signing session
	SignerKey text, -- Instigator's signing key
	Signature text, -- Instigator's signature of this row
	primary key (Nonce),
	constraint InsertOnly check on update, delete (false),
	constraint ScopeValid check (exists (select 1 from Scope S where S.Code = new.Scope)),
	constraint UserSidValid check (exists (
		select 1 from Officer O
			where O.UserSid = new.UserSid
				and O.AdminEffectiveAt = new.AdminEffectiveAt
				and O.AuthoritySid = new.AuthoritySid
	)),
	constraint SignerKeyValid check (exists (select 1 from UserKey K where K.UserSid = new.UserSid and K.Key = new.SignerKey and K.Expiration > datetime('now'))),
	constraint SignatureValid check (SignatureValid(Digest(Nonce, AuthoritySid, AdminEffectiveAt, Scope, Digest, UserSid), Signature, SignerKey))
);

-- Officer's signature on the signing session
create table OfficerSignature (
	SigningNonce text,
	UserSid text,	-- Particular Officer
	SignerKey text,	-- User's particular signing key
	Signature text,	-- User's signature of the digest
	primary key (SigningNonce, UserSid),
	constraint InsertOnly check on update, delete (false),
	-- Key is valid for the user and the UserSid is valid
	constraint SignerKeyValid check (
		exists (select 1 from UserKey K where K.UserSid = new.UserSid and K.Key = new.SignerKey and K.Expiration > datetime('now'))
	),
	-- User is an Officer with the required scope
	constraint OfficerValid check (
		exists (select 1 from AdminSigning ADS
			join Officer O on O.AuthoritySid = ADS.AuthoritySid and O.AdminEffectiveAt = ADS.AdminEffectiveAt
			where ADS.Nonce = new.SigningNonce
				 and O.UserSid = new.UserSid
				 and ADS.Scope in (select policy from json_array_elements_text(O.Scopes) S(s) where s = new.Scope)
		)
	),
	constraint SignatureValid check (exists (
		select 1 from AdminSigning ADS
			where ADS.Nonce = new.SigningNonce
				and SignatureValid(ADS.Digest, Signature, SignerKey)
	))
);

-- The final Admin signature output - only exists if required threshold of signatures are met - exists to avoid long validation
create table AdminSignature (
	SigningNonce text,
	primary key (SigningNonce),
	constraint InsertOnly check on update, delete (false),
	-- Satisfies the threshold policies of the Admin for the given scope
	constraint SignatureValid check (
		(select count(*) from OfficerSignature ADS where ADS.SigningNonce = new.SigningNonce)
			>= (
				select threshold from Admin A
					join AuthoritySignature ATS on ATS.AuthoritySid = A.AuthoritySid and ATS.AdminEffectiveAt = A.EffectiveAt
					cross join lateral json_array_elements_text(A.ThresholdPolicies) TP(tp) on tp.scope = ATS.Scope
					where ATS.Nonce = new.SigningNonce
			)
	)
);

-- The ProposedAdmin [Nonce] is recorded as having existed, enabling deletion without risk of unauthorized re-insertion
create table ExistedProposedAdmin (
	Nonce text,
	primary key (Nonce),
);

create table ProposedAdmin (
	Nonce text,
	AuthoritySid text,
	EffectiveAt datetime,
	ThresholdPolicies text default '[]', -- json array of { policy: string (Scope), threshold: integer }
	primary key (AuthoritySid, EffectiveAt),
	constraint InsertValid check on insert (not exists (select 1 from ExistedProposedAdmin E where E.Nonce = new.Nonce)),
	constraint DeleteValid check on delete (exists (select 1 from ExistedProposedAdmin E where E.Nonce = new.Nonce)),
	constraint AuthoritySidValid check (exists (select 1 from Authority A where A.Sid = new.AuthoritySid)),
	-- TODO: Replace with isISODatetime when available
	constraint EffectiveAtValid check on insert, update(datetime(EffectiveAt) is not null),
	--constraint ThresholdPoliciesValid check (...), -- TODO: constraint
	constraint UserValid check (exists (
		select 1 from Officer O
			join CurrentAdmin CA on CA.AuthoritySid = O.AuthoritySid and CA.EffectiveAt = O.AdminEffectiveAt
			join UserKey K on K.UserSid = O.UserSid and K.Key = context.UserKey and K.Expiration > datetime('now')
			where O.UserSid = context.UserSid and O.AuthoritySid = new.AuthoritySid
				and exists(select 1 from json_array_elements_text(O.Scopes) S(s) where s = 'rad')
				and SignatureValid(
					Digest(Nonce, Coalesce(new.AuthoritySid, old.AuthoritySid),
						Coalesce(new.EffectiveAt, old.EffectiveAt), ThresholdPolicies),
					context.Signature,
					context.UserKey
				)
	)),
)
	with context ( UserSid text, UserKey text, Signature text );

alter table ExistedProposedAdmin
	add constraint NonceValid check (exists (select 1 from ProposedAdmin P where P.Nonce = new.Nonce));

create table ProposedOfficer (
	AuthoritySid text,
	AdminEffectiveAt datetime,
	AdminNonce text,
	ProposedName text,
	Title text,
	Scopes text default '[]', -- json array of strings
	OfficerKey text,	-- Key of some current Officer
	OfficerSignature text,
	primary key (AuthoritySid, AdminEffectiveAt, ProposedName),
	constraint AuthoritySidValid check (exists (select 1 from Authority A where A.Sid = new.AuthoritySid)),
	constraint AdminValid check (exists (select 1 from Admin A where A.AuthoritySid = new.AuthoritySid and A.Revision = new.AdminRevision)),
	constraint CantDelete check on delete (false),
	constraint ScopesValid check (not exists (select 1 from json_array_elements_text(Scopes) S(s) where s not in (select Code from Scope))),
	constraint OfficerKeyValid check (exists (select 1 from UserKey K
		-- Most recent effective Admin
		join Officer A on A.UserSid = K.UserSid and A.AdminEffectiveAt <= datetime('now')
		join Admin AD on AD.AuthoritySid = A.AuthoritySid and AD.E
		where K.UserSid = new.OfficerKey and K.Expiration > datetime('now')))
);

-- Extension of ProposedOfficer to associate a specific UserSid and include the user's signature
create table ProposedOfficerUser (
	AuthoritySid text,
	AdminEffectiveAt datetime,
	ProposedName text,
	UserSid text,
	UserKey text,
	UserSignature text,
	primary key (AuthoritySid, AdminEffectiveAt, ProposedName),
	constraint ProposedOfficerValid check (exists (select 1 from ProposedOfficer PA where PA.AuthoritySid = new.AuthoritySid and PA.AdminEffectiveAt = new.AdminEffectiveAt and PA.ProposedName = new.ProposedName)),
	constraint UserSidValid check (exists (select 1 from User U where U.Sid = new.UserSid)),
	constraint UserKeyValid check (exists (select 1 from UserKey K where K.UserSid = new.UserSid and K.Key = new.UserKey and K.Expiration > datetime('now'))),
	constraint CantDelete check on delete (false),
	constraint SignatureValid check (exists (
		select 1 from ProposedOfficer PA
			where PA.AuthoritySid = new.AuthoritySid and PA.AdminRevision = new.AdminRevision and PA.ProposedName = new.ProposedName and PA.UserSid = new.UserSid and PA.SignerKey = new.SignerKey and PA.Signature = new.Signature
			-- and SignatureValid(
			-- 	Digest(new.AuthoritySid, new.AdminRevision, new.UserSid, PA.Title, PA.Scopes),
			-- 	Signature,
			-- 	SignerKey
			-- )
	))
);

create table InviteSlot (
	Cid text,
	-- Name of person or authority for informational purpose and/or manually catch abuse
	Name text,
	Expiration text,
	InviteKey text, -- public key of temporary Invite key pair
	InviteSignature text,
	SigningNonce text, -- Admin approval, including scope (implies the type of invite, e.g. authority, Officer, keyholder, registrant)
	primary key (Cid),
	constraint CidValid check (Cid = Digest(Name, Expiration, InviteKey, InviteSignature, SigningNonce)),
	constraint ExpirationValid check (Expiration > datetime('now')),
	-- Prooves that the inviter has a valid private key corresponding to the public key in the Invite slot
	constraint InviteSignatureValid check (SignatureValid(Digest(Cid, Type, Name, Expiration), InviteSignature, InviteKey)),
	constraint InsertOnly check on update, delete (false)
)

create index InviteSlotSigningNonce on InviteSlot (SigningNonce, Cid);

-- A single signing can encompass a batch of Invite slots, so validate the whole batch at once
create assertion InviteSlotSigningValid check (not exists (
	select 1 from (
		select SigningNonce, Digest(Cid) over (order by Cid) as Digest from InviteSlot I
	) SND
		where not exists (
			select 1 from AdminSigning SIG
				where SIG.SigningNonce = SND.SigningNonce and SIG.Digest = SND.Digest
		)
));

-- Acceptance or rejection of Invite, created before resulting object
create table InviteResult (
	SlotCid text primary key,
	IsAccepted boolean,	-- If Not accepted, Digest must be null
	Digest text null,	-- On whatever the invited party is intending to create - not validated here besides not null if IsAccepted
	InviteSignature text,	-- Signs H(SlotCid, Digest, IsAccepted)
	constraint InsertOnly check on update, delete (false),
	constraint SigningValid check (exists (
		select 1 from InviteSlot I
			join AdminSignature SIG on SIG.Nonce = I.SigningNonce
			where I.Cid = new.SlotCid)
	),
	constraint SignatureValid check (exists (
		select 1 from InviteSlot S
			where S.Cid = new.SlotCid and SignatureValid(Digest(SlotCid, Digest, IsAccepted), new.InviteSignature, S.InviteKey)
	)),
	constraint DigestValid check (
		(not IsAccepted and new.Digest is null)
			or (IsAccepted and new.Digest is not null)
	),
);

create view UserKeyType as
	select Code, Name from (values ('M', 'Mobile'), ('Y', 'Yubico')) as UserKeyType(Code, Name);

create table UserKey (
	UserSid text, -- references future User.Sid
	Type text, -- references UserKeyType(Code)
	Key text,
	Expiration text,
	primary key (UserSid, Key),
	constraint SidValid check (
		not exists (select 1 from UserKey)
			or exists (
				select 1 from InviteSlot I
					join InviteResult IR on IR.SlotCid = I.Cid and IR.IsAccepted
					where I.Cid = new.UserSid
			)
	),
	constraint ExpirationFuture check (Expiration > datetime('now')),
	constraint CantUpdate check on update (false)
);

create table User (
	Sid text, -- references InviteSlot.Cid (of accepted Invite)
	Name text,
	ImageRef text null, -- json object { url?: string, cid?: string }
	SignerKey text,
	Signature text,
	primary key (Sid),
	constraint SidValid check (
		not exists (select 1 from User)
			or exists (
				select 1 from InviteSlot I
					join InviteResult IR on IR.SlotCid = I.Cid and IR.IsAccepted
					where I.Cid = new.Sid
			)
	),
	constraint SignerKeyValid check (
		exists (select 1 from UserKey K where K.UserSid = new.Sid and K.Key = new.SignerKey and K.Expiration > datetime('now'))
	),
	constraint SignatureValid check (SignatureValid(Digest(Sid, Name, ImageRef), Signature, SignerKey)),
	constraint CantDelete check on delete (false),
	constraint ValidModification check (new.Sid = old.Sid)
);
